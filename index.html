<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Multiplayer Hats</title>
  <style>
    body { margin:0; overflow:hidden; }
    #colorPicker {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
    }
  </style>
</head>
<body>
<input type="color" id="colorPicker" value="#888888" />

<script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

<script>
window.addEventListener("contextmenu", e => e.preventDefault());

// Firebase
const firebaseConfig = {
  apiKey: "AIzaSyC_Op87WdFH-xBlbyBPgH66LilwGZ8Ch5w",
  authDomain: "pasja-data5100s.firebaseapp.com",
  projectId: "pasja-data5100s",
  storageBucket: "pasja-data5100s.firebasestorage.app",
  messagingSenderId: "1042573635103",
  appId: "1:1042573635103:web:9f70d20e5ac49f951b6f2a",
  measurementId: "G-Z2GYGXQTMZ"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// Scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Character model
function createCharacter(color) {
  const mat = new THREE.MeshStandardMaterial({ color });
  const group = new THREE.Group();

  const head = new THREE.Mesh(new THREE.BoxGeometry(1.25, 1.25, 1.25), mat);
  head.position.y = 3.25;
  head.castShadow = true;
  head.name = "head";
  group.add(head);

  const torso = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), mat);
  torso.position.y = 1.5;
  torso.castShadow = true;
  group.add(torso);

  const leftArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
  leftArm.position.set(-1.5, 1.5, 0);
  leftArm.castShadow = true;
  group.add(leftArm);

  const rightArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
  rightArm.position.set(1.5, 1.5, 0);
  rightArm.castShadow = true;
  group.add(rightArm);

  const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
  leftLeg.position.set(-0.5, -0.5, 0);
  leftLeg.castShadow = true;
  group.add(leftLeg);

  const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
  rightLeg.position.set(0.5, -0.5, 0);
  rightLeg.castShadow = true;
  group.add(rightLeg);

  return group;
}

// Detailed Hats
function makeHat(type) {
  let hat;
  switch(type) {
    case "valkyrie":
      hat = new THREE.Group();
      const helm = new THREE.Mesh(
        new THREE.CylinderGeometry(0.7,0.9,0.6,24,1,true),
        new THREE.MeshStandardMaterial({ color:0x555577, metalness:0.6, roughness:0.3 })
      );
      helm.position.y = 0.3;
      hat.add(helm);

      const gem = new THREE.Mesh(
        new THREE.OctahedronGeometry(0.2),
        new THREE.MeshStandardMaterial({ color:0x44aaff, emissive:0x2255ff })
      );
      gem.position.set(0,0.35,0.8);
      hat.add(gem);

      const featherMat = new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.8 });
      for (let side of [-1,1]) {
        for (let i=0;i<4;i++) {
          const feather = new THREE.Mesh(new THREE.BoxGeometry(0.1,0.5,0.15), featherMat);
          feather.position.set(side*0.9,0.5+i*0.4,-0.1*i);
          feather.rotation.z = side*0.2;
          hat.add(feather);
        }
      }
      break;

    case "topHat":
      hat = new THREE.Group();
      const brim = new THREE.Mesh(
        new THREE.CylinderGeometry(1,1,0.15,32),
        new THREE.MeshStandardMaterial({ color:0x000000, roughness:0.4 })
      );
      brim.position.y = 0;
      hat.add(brim);

      const tall = new THREE.Mesh(
        new THREE.CylinderGeometry(0.7,0.7,1.6,32),
        new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.3 })
      );
      tall.position.y = 0.9;
      hat.add(tall);

      const band = new THREE.Mesh(
        new THREE.CylinderGeometry(0.72,0.72,0.2,32),
        new THREE.MeshStandardMaterial({ color:0xaa0000, metalness:0.2 })
      );
      band.position.y = 0.2;
      hat.add(band);
      break;

    case "hood":
      hat = new THREE.Group();
      const hoodMat = new THREE.MeshStandardMaterial({ color:0x00aa66, side:THREE.DoubleSide, roughness:0.7 });
      const outer = new THREE.Mesh(
        new THREE.SphereGeometry(1.0,24,16,0,Math.PI*2,0,Math.PI/2),
        hoodMat
      );
      outer.scale.set(1,1.2,1);
      outer.position.y = 0.4;
      hat.add(outer);

      const rim = new THREE.Mesh(
        new THREE.TorusGeometry(1,0.1,8,24,Math.PI),
        new THREE.MeshStandardMaterial({ color:0x007744 })
      );
      rim.rotation.x = Math.PI/2;
      rim.position.y = 0.1;
      hat.add(rim);
      break;

    case "sunglasses":
      hat = new THREE.Group();
      const glassMat = new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.6, roughness:0.2 });
      const frameMat = new THREE.MeshStandardMaterial({ color:0x000000, metalness:0.8 });

      const lens1 = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.05,16), glassMat);
      const lens2 = lens1.clone();
      lens1.rotation.x = Math.PI/2;
      lens2.rotation.x = Math.PI/2;
      lens1.position.set(-0.45,0,0.7);
      lens2.position.set(0.45,0,0.7);
      hat.add(lens1); hat.add(lens2);

      const bridge = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.05,0.05), frameMat);
      bridge.position.set(0,0,0.7);
      hat.add(bridge);

      for (let side of [-1,1]) {
        const temple = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.05,0.6), frameMat);
        temple.position.set(side*0.65,0,0.4);
        hat.add(temple);
      }
      break;
  }
  if(hat) hat.name = "hat";
  return hat;
}

// Player + networking
const player = createCharacter(0x888888);
scene.add(player);
const players = {};
const playerId = Math.random().toString(36).substr(2, 9);

// Camera controls
let radius = 5, theta = 0, phi = Math.PI/4;
let isDragging = false, lastX, lastY;
function updateCamera() {
  const target = player.position;
  camera.position.x = target.x + radius * Math.sin(phi) * Math.cos(theta);
  camera.position.y = target.y + radius * Math.cos(phi);
  camera.position.z = target.z + radius * Math.sin(phi) * Math.sin(theta);
  camera.lookAt(target);
}
updateCamera();

window.addEventListener("mousedown", e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
window.addEventListener("mouseup", () => isDragging = false);
window.addEventListener("mousemove", e => {
  if (!isDragging) return;
  let dx = e.clientX - lastX;
  let dy = e.clientY - lastY;
  theta -= dx * 0.01;
  phi -= dy * 0.01;
  phi = Math.max(0.1, Math.min(Math.PI-0.1, phi));
  updateCamera();
  lastX = e.clientX; lastY = e.clientY;
});
window.addEventListener("wheel", e => {
  radius += e.deltaY*0.01;
  radius = Math.max(2, Math.min(20, radius));
  updateCamera();
});

// Database reference
const playerRef = db.ref("players/" + playerId);
playerRef.set({ x:0, y:0, z:0, color:"#888888", hat:null });
playerRef.onDisconnect().remove();

// Color picker
document.getElementById("colorPicker").addEventListener("input", e => {
  player.traverse(obj => { if (obj.isMesh) obj.material.color.set(e.target.value); });
  playerRef.update({ color:e.target.value });
});

// Listen for other players
db.ref("players").on("value", snapshot => {
  const data = snapshot.val() || {};
  for (let id in data) {
    if (id===playerId) continue;
    if (!players[id]) {
      const mesh = createCharacter(data[id].color);
      scene.add(mesh);
      players[id] = { mesh, hat:null };
    }
    const p = players[id];
    p.mesh.traverse(obj => { if (obj.isMesh) obj.material.color.set(data[id].color); });
    p.mesh.position.set(data[id].x, data[id].y, data[id].z);

    // Update hat
    if (p.hat) { p.mesh.getObjectByName("head").remove(p.hat); p.hat=null; }
    if (data[id].hat) {
      p.hat = makeHat(data[id].hat);
      if (p.hat) {
        p.hat.position.y = 0.9;
        p.mesh.getObjectByName("head").add(p.hat);
      }
    }
  }
  for (let id in players) {
    if (!data[id]) {
      scene.remove(players[id].mesh);
      delete players[id];
    }
  }
});

// Movement
const keys = {};
window.addEventListener("keydown", e => keys[e.key]=true);
window.addEventListener("keyup", e => keys[e.key]=false);

// Equip hats (1-4, 0 to remove)
window.addEventListener("keydown", e => {
  if (e.key==="1") playerRef.update({ hat:"valkyrie" });
  if (e.key==="2") playerRef.update({ hat:"topHat" });
  if (e.key==="3") playerRef.update({ hat:"hood" });
  if (e.key==="4") playerRef.update({ hat:"sunglasses" });
  if (e.key==="0") playerRef.update({ hat:null });
});

// Floor
const floorSize = 200, tiles = 20;
const floorCanvas = document.createElement("canvas");
floorCanvas.width = floorCanvas.height = 512;
const ctx = floorCanvas.getContext("2d");
for (let y=0;y<8;y++){
  for(let x=0;x<8;x++){
    ctx.fillStyle = (x+y)%2===0 ? "#ffffff" : "#999999";
    ctx.fillRect(x*64,y*64,64,64);
  }
}
const floorTexture = new THREE.CanvasTexture(floorCanvas);
floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
floorTexture.repeat.set(tiles, tiles);
const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, side: THREE.DoubleSide });
const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), floorMaterial);
floorMesh.rotation.x = -Math.PI/2;
floorMesh.receiveShadow = true;
scene.add(floorMesh);

// Lighting
const ambientLight = new THREE.AmbientLight(0xffffff,0.6);
scene.add(ambientLight);
const sunLight = new THREE.DirectionalLight(0xffffff,1);
sunLight.position.set(50,100,50);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width=2048;
sunLight.shadow.mapSize.height=2048;
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 500;
scene.add(sunLight);

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  let moved=false;
  if (keys["w"]){player.position.z-=0.05;moved=true;}
  if (keys["s"]){player.position.z+=0.05;moved=true;}
  if (keys["a"]){player.position.x-=0.05;moved=true;}
  if (keys["d"]){player.position.x+=0.05;moved=true;}
  if (moved) playerRef.update({x:player.position.x,y:player.position.y,z:player.position.z});
  updateCamera();
  renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>


