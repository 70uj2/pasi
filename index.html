<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Multiplayer Hats â€” restored</title>
  <style>
    body { margin:0; overflow:hidden; background:#111; }
    #colorPicker { position:absolute; top:10px; right:10px; z-index:10; }
    #ui {
      position:absolute; top:10px; left:10px;
      background:rgba(0,0,0,0.6);
      padding:10px; border-radius:8px;
      display:flex; flex-direction:column; gap:6px; z-index:10;
    }
    #ui button {
      padding:6px 10px; font-size:14px;
      border:none; border-radius:4px;
      background:#333; color:#fff;
      cursor:pointer;
    }
    #ui button.active { background:#1e88e5; }
    #ui button:hover { background:#555; }
  </style>
</head>
<body>
  <div id="ui">
    <button data-hat="valkyrie">Valkyrie</button>
    <button data-hat="topHat">Top Hat</button>
    <button data-hat="hood">Viridian Hood</button>
    <button data-hat="sunglasses">Sunglasses</button>
    <button data-hat="">Remove Hat</button>
  </div>

  <input type="color" id="colorPicker" value="#888888" />

  <!-- THREE + Firebase (compat) -->
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

  <script>
  // prevent right-click context menu (like you had)
  window.addEventListener("contextmenu", e => e.preventDefault());

  // ---------- Firebase config (with databaseURL) ----------
  const firebaseConfig = {
    apiKey: "AIzaSyC_Op87WdFH-xBlbyBPgH66LilwGZ8Ch5w",
    authDomain: "pasja-data5100s.firebaseapp.com",
    databaseURL: "https://pasja-data5100s-default-rtdb.firebaseio.com",
    projectId: "pasja-data5100s",
    storageBucket: "pasja-data5100s.firebasestorage.app",
    messagingSenderId: "1042573635103",
    appId: "1:1042573635103:web:9f70d20e5ac49f951b6f2a",
    measurementId: "G-Z2GYGXQTMZ"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ---------- Local player id + DB ref ----------
  const playerId = Math.random().toString(36).substr(2,9);
  const playerRef = db.ref("players/" + playerId);
  // initialize minimal state (keeps color + hat as fields)
  playerRef.set({ x:0, y:0, z:0, color:"#888888", hat:null });
  playerRef.onDisconnect().remove();

  // ---------- THREE scene ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // lighting
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(50,100,50);
  sun.castShadow = true;
  sun.shadow.mapSize.width = sun.shadow.mapSize.height = 2048;
  scene.add(sun);

  // checkered floor (similar to your original)
  const floorSize = 200, tiles = 20;
  const floorCanvas = document.createElement("canvas");
  floorCanvas.width = floorCanvas.height = 512;
  const ctx = floorCanvas.getContext("2d");
  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      ctx.fillStyle = (x + y) % 2 === 0 ? "#ffffff" : "#999999";
      ctx.fillRect(x * 64, y * 64, 64, 64);
    }
  }
  const floorTexture = new THREE.CanvasTexture(floorCanvas);
  floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
  floorTexture.repeat.set(tiles, tiles);
  const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, side: THREE.DoubleSide });
  const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(floorSize, floorSize), floorMaterial);
  floorMesh.rotation.x = -Math.PI/2;
  floorMesh.receiveShadow = true;
  scene.add(floorMesh);

  // ---------- Character model (same shapes as you used before) ----------
  function createCharacter(color) {
    const mat = new THREE.MeshStandardMaterial({ color });
    const group = new THREE.Group();

    const head = new THREE.Mesh(new THREE.BoxGeometry(1.25, 1.25, 1.25), mat);
    head.position.y = 3.25;
    head.castShadow = true;
    head.name = "head";
    group.add(head);

    const torso = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), mat);
    torso.position.y = 1.5; torso.castShadow = true; group.add(torso);

    const leftArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
    leftArm.position.set(-1.5, 1.5, 0); leftArm.castShadow = true; group.add(leftArm);

    const rightArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
    rightArm.position.set(1.5, 1.5, 0); rightArm.castShadow = true; group.add(rightArm);

    const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
    leftLeg.position.set(-0.5, -0.5, 0); leftLeg.castShadow = true; group.add(leftLeg);

    const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), mat);
    rightLeg.position.set(0.5, -0.5, 0); rightLeg.castShadow = true; group.add(rightLeg);

    return group;
  }

  // your local player
  const player = createCharacter("#888888");
  scene.add(player);

  // other players map: id -> { mesh, hatName, hatObject }
  const players = {};

  // ---------- Hat creation (detailed procedural hats) ----------
  function makeHat(type) {
    let hat = null;

    switch(type) {
      case "valkyrie": {
        hat = new THREE.Group();
        const helm = new THREE.Mesh(
          new THREE.CylinderGeometry(0.7, 0.9, 0.6, 24, 1, true),
          new THREE.MeshStandardMaterial({ color:0x555577, metalness:0.6, roughness:0.3 })
        );
        helm.position.y = 0.3; hat.add(helm);

        const gem = new THREE.Mesh(
          new THREE.OctahedronGeometry(0.18),
          new THREE.MeshStandardMaterial({ color:0x44aaff, emissive:0x2244ff })
        );
        gem.position.set(0,0.35,0.8); hat.add(gem);

        const featherMat = new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.8 });
        for (let side of [-1,1]) {
          for (let i=0;i<4;i++) {
            const feather = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.45,0.12), featherMat);
            feather.position.set(side*0.92, 0.45 + i*0.32, -0.08*i);
            feather.rotation.z = side * (0.18 + i*0.02);
            feather.rotation.y = side * 0.05;
            hat.add(feather);
          }
        }
        break;
      }

      case "topHat": {
        hat = new THREE.Group();
        const brim = new THREE.Mesh(
          new THREE.CylinderGeometry(1.02, 1.02, 0.14, 32),
          new THREE.MeshStandardMaterial({ color:0x000000, roughness:0.4 })
        );
        brim.position.y = 0; hat.add(brim);

        const tall = new THREE.Mesh(
          new THREE.CylinderGeometry(0.7, 0.7, 1.6, 32),
          new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.3 })
        );
        tall.position.y = 0.9; hat.add(tall);

        const band = new THREE.Mesh(
          new THREE.CylinderGeometry(0.72, 0.72, 0.18, 32),
          new THREE.MeshStandardMaterial({ color:0xaa0000, metalness:0.2 })
        );
        band.position.y = 0.22; hat.add(band);
        break;
      }

      case "hood": {
        hat = new THREE.Group();
        const hoodMat = new THREE.MeshStandardMaterial({ color:0x00aa66, side:THREE.DoubleSide, roughness:0.7 });
        const outer = new THREE.Mesh(
          new THREE.SphereGeometry(1.0, 28, 18, 0, Math.PI*2, 0, Math.PI/2),
          hoodMat
        );
        outer.scale.set(1,1.18,1);
        outer.position.y = 0.4; hat.add(outer);

        const rim = new THREE.Mesh(
          new THREE.TorusGeometry(1, 0.1, 10, 24, Math.PI),
          new THREE.MeshStandardMaterial({ color:0x007744 })
        );
        rim.rotation.x = Math.PI/2; rim.position.y = 0.08; hat.add(rim);
        break;
      }

      case "sunglasses": {
        hat = new THREE.Group();
        const glassMat = new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.6, roughness:0.2 });
        const frameMat = new THREE.MeshStandardMaterial({ color:0x000000, metalness:0.8 });

        const lens1 = new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.05,16), glassMat);
        const lens2 = lens1.clone();
        lens1.rotation.x = Math.PI/2; lens2.rotation.x = Math.PI/2;
        lens1.position.set(-0.45, 0, 0.72);
        lens2.position.set( 0.45, 0, 0.72);
        hat.add(lens1); hat.add(lens2);

        const bridge = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.05,0.05), frameMat);
        bridge.position.set(0,0,0.72); hat.add(bridge);

        for (let side of [-1,1]) {
          const temple = new THREE.Mesh(new THREE.BoxGeometry(0.05,0.05,0.6), frameMat);
          temple.position.set(side*0.65, 0, 0.34);
          temple.rotation.y = side * 0.05;
          hat.add(temple);
        }
        break;
      }
    }

    if (hat) {
      hat.name = "hat";
      hat.position.set(0, 0.9, 0); // will be attached to the head, sits on top
    }
    return hat;
  }

  // helper: attach hat to a character group (assumes head exists)
  function attachHatToCharacter(characterGroup, hatType) {
    // remove old
    const head = characterGroup.getObjectByName("head");
    if (!head) return null;

    const old = head.getObjectByName("hat");
    if (old) head.remove(old);

    if (!hatType) return null;
    const hat = makeHat(hatType);
    if (hat) head.add(hat);
    return hat;
  }

  // ---------- Camera controls (custom orbit around player) ----------
  let radius = 5, theta = 0, phi = Math.PI/4;
  let isDragging = false, lastX = 0, lastY = 0;

  function updateCamera() {
    const target = player.position;
    camera.position.x = target.x + radius * Math.sin(phi) * Math.cos(theta);
    camera.position.y = target.y + radius * Math.cos(phi);
    camera.position.z = target.z + radius * Math.sin(phi) * Math.sin(theta);
    camera.lookAt(target);
  }
  updateCamera();

  window.addEventListener("mousedown", e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
  window.addEventListener("mouseup", () => isDragging = false);
  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - lastX, dy = e.clientY - lastY;
    theta -= dx * 0.01;
    phi -= dy * 0.01;
    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
    updateCamera();
    lastX = e.clientX; lastY = e.clientY;
  });
  window.addEventListener("wheel", e => {
    radius += e.deltaY * 0.01;
    radius = Math.max(2, Math.min(50, radius));
    updateCamera();
  });

  // ---------- Movement (WASD) ----------
  const keys = {};
  window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
  window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

  // movement speed
  const speed = 0.06;

  // ---------- Color picker ----------
  const colorPicker = document.getElementById("colorPicker");
  colorPicker.addEventListener("input", e => {
    const color = e.target.value;
    player.traverse(o => { if (o.isMesh) o.material.color.set(color); });
    // update only the color field so we don't wipe other data
    playerRef.update({ color });
  });

  // ---------- UI hat buttons ----------
  const ui = document.getElementById("ui");
  ui.addEventListener("click", e => {
    const btn = e.target.closest("button[data-hat]");
    if (!btn) return;
    const hatType = btn.getAttribute("data-hat") || null;

    // apply locally right away
    attachHatToCharacter(player, hatType);

    // update DB (use update so other fields aren't overwritten)
    playerRef.update({ hat: hatType });

    // button highlight (visual)
    ui.querySelectorAll("button").forEach(b => b.classList.remove("active"));
    if (hatType) btn.classList.add("active");
  });

  // ---------- Firebase listener: all players ----------
  db.ref("players").on("value", snapshot => {
    const data = snapshot.val() || {};

    // create / update players
    for (const id in data) {
      const p = data[id];
      if (id === playerId) {
        // keep local player state in control locally; but reflect if DB changed externally
        if (p.color) {
          // ensure local player color matches DB if changed elsewhere
          player.traverse(o => { if (o.isMesh) o.material.color.set(p.color); });
          colorPicker.value = p.color;
        }
        // local hat is handled by UI (but we also ensure DB-driven change is applied)
        if (p.hat !== undefined) {
          // apply if not already present or different
          const head = player.getObjectByName("head");
          const existing = head.getObjectByName("hat");
          if ((existing && existing.userData?.hatType !== p.hat) || (!existing && p.hat)) {
            attachHatToCharacter(player, p.hat);
            const btns = ui.querySelectorAll("button");
            btns.forEach(b => b.classList.remove("active"));
            if (p.hat) {
              const btn = ui.querySelector(`button[data-hat="${p.hat}"]`);
              if (btn) btn.classList.add("active");
            }
            if (head.getObjectByName("hat")) head.getObjectByName("hat").userData = { hatType: p.hat };
          }
        }
        continue;
      }

      // other players
      if (!players[id]) {
        // create character with their color if present
        const mesh = createCharacter(p.color || "#888888");
        scene.add(mesh);
        players[id] = { mesh, hatType: null, hatObj: null };
      }
      const rec = players[id];
      // update color
      if (p.color) {
        rec.mesh.traverse(o => { if (o.isMesh) o.material.color.set(p.color); });
      }
      // update position
      rec.mesh.position.set(p.x || 0, p.y || 0, p.z || 0);

      // update hat
      if (rec.hatType !== p.hat) {
        // remove existing
        const head = rec.mesh.getObjectByName("head");
        if (rec.hatObj && head) head.remove(rec.hatObj);
        rec.hatObj = null;
        if (p.hat) {
          const hatObj = makeHat(p.hat);
          if (hatObj && head) {
            head.add(hatObj);
            hatObj.userData = { hatType: p.hat };
            rec.hatObj = hatObj;
          }
        }
        rec.hatType = p.hat || null;
      }
    }

    // remove disconnected players
    for (const id in players) {
      if (!data[id]) {
        scene.remove(players[id].mesh);
        delete players[id];
      }
    }
  });

  // ---------- Animation loop ----------
  function animate() {
    requestAnimationFrame(animate);

    // movement
    let moved = false;
    if (keys["w"]) { player.position.z -= speed; moved = true; }
    if (keys["s"]) { player.position.z += speed; moved = true; }
    if (keys["a"]) { player.position.x -= speed; moved = true; }
    if (keys["d"]) { player.position.x += speed; moved = true; }

    if (moved) {
      // update only position fields
      playerRef.update({
        x: player.position.x,
        y: player.position.y,
        z: player.position.z
      });
    }

    updateCamera();
    renderer.render(scene, camera);
  }
  animate();

  // ---------- Resize ----------
  window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
  </script>
</body>
</html>
