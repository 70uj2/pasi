<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Three.js Firebase Multiplayer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="data:,">
<style>
  html,body { height:100%; margin:0; background:#111; overflow:hidden; }
  #canvas { display:block; width:100%; height:100vh; }
  .ui {
    position: absolute; right: 12px; top: 12px;
    background: rgba(0,0,0,0.35); padding:10px; border-radius:8px;
    backdrop-filter: blur(4px);
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="ui">
  <input id="color" type="color" value="#888888" />
</div>

<script type="module">
/* ----------------------------
  Multiplayer Three.js demo
  Realtime DB via Firebase (v9 modular)
  ---------------------------- */

// import three.js and orbit controls from CDN
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// import firebase modular SDK (Realtime Database)
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js';
import {
  getDatabase, ref, set, onDisconnect, remove, update,
  onChildAdded, onChildRemoved, onChildChanged
} from 'https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js';

/* ========  YOUR FIREBASE CONFIG  ======== */
const firebaseConfig = {
  apiKey: "AIzaSyC_Op87WdFH-xBlbyBPgH66LilwGZ8Ch5w",
  authDomain: "pasja-data5100s.firebaseapp.com",
  databaseURL: "https://pasja-data5100s-default-rtdb.firebaseio.com",
  projectId: "pasja-data5100s",
  storageBucket: "pasja-data5100s.appspot.com",
  messagingSenderId: "1042573635103",
  appId: "1:1042573635103:web:9f70d20e5ac49f951b6f2a",
  measurementId: "G-Z2GYGXQTMZ"
};
/* ========================================= */

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/////////// simple player id
const myId = Math.random().toString(36).substring(2,8);

/* -------- Three.js scene setup -------- */
const canvas = document.getElementById('canvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 8, 12);

const controls = new OrbitControls(camera, renderer.domElement);
controls.target.set(0,1,0);
controls.update();

/* lighting */
scene.add(new THREE.HemisphereLight(0xffffff, 0x222224, 0.9));
const dir = new THREE.DirectionalLight(0xffffff, 0.7);
dir.position.set(5,10,7);
scene.add(dir);

/* ground */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(200,200),
  new THREE.MeshStandardMaterial({color:0x222222})
);
ground.rotation.x = -Math.PI/2;
scene.add(ground);

/* my player (a cube) */
const playerHeight = 1.6;
const cubeGeo = new THREE.BoxGeometry(1, playerHeight, 1);
const myColorInput = document.getElementById('color');
let myColor = myColorInput.value;
const myMat = new THREE.MeshStandardMaterial({color: myColor});
const myMesh = new THREE.Mesh(cubeGeo, myMat);
myMesh.position.set(0, playerHeight/2, 0);
scene.add(myMesh);

/* other players map */
const others = new Map();

/* resize */
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* simple movement */
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function movementVector(dt){
  const speed = 5;
  let x=0,z=0;
  if (keys.w || keys.ArrowUp) z -= 1;
  if (keys.s || keys.ArrowDown) z += 1;
  if (keys.a || keys.ArrowLeft) x -= 1;
  if (keys.d || keys.ArrowRight) x += 1;
  const len = Math.hypot(x,z);
  if (len > 0){ x = (x/len) * speed * dt; z = (z/len) * speed * dt; }
  return {x,z};
}

/* Firebase presence */
const myRef = ref(db, `players/${myId}`);
set(myRef, {x:0, y:playerHeight/2, z:0, color:myColor});
onDisconnect(myRef).remove();

/* update my color */
myColorInput.addEventListener('input', (e) => {
  myColor = e.target.value;
  myMesh.material.color.set(myColor);
  update(myRef, { color: myColor });
});

/* listen for other players */
function addOrUpdateRemote(id, val){
  if (id===myId) return;
  let entry = others.get(id);
  if (!entry){
    const mat = new THREE.MeshStandardMaterial({color: val.color || '#999'});
    const mesh = new THREE.Mesh(cubeGeo, mat);
    scene.add(mesh);
    entry = { mesh, target: new THREE.Vector3(val.x||0, playerHeight/2, val.z||0) };
    mesh.position.copy(entry.target);
    others.set(id, entry);
  } else {
    if (val.color) entry.mesh.material.color.set(val.color);
    entry.target.set(val.x||0, playerHeight/2, val.z||0);
  }
}

onChildAdded(ref(db,'players'), snap => addOrUpdateRemote(snap.key, snap.val()));
onChildChanged(ref(db,'players'), snap => addOrUpdateRemote(snap.key, snap.val()));
onChildRemoved(ref(db,'players'), snap => {
  const entry = others.get(snap.key);
  if (entry){ scene.remove(entry.mesh); others.delete(snap.key); }
});

/* main loop */
let lastT = performance.now();
let lastSent = 0;
function animate(t){
  const dt = Math.min(0.1, (t - lastT)/1000); lastT = t;
  const mv = movementVector(dt);
  myMesh.position.x += mv.x; myMesh.position.z += mv.z;
  if (Math.abs(mv.x)+Math.abs(mv.z) > 0.001) myMesh.rotation.y = Math.atan2(mv.x, mv.z);

  // send updates
  if (t - lastSent > 100){
    lastSent = t;
    update(myRef, { x: myMesh.position.x, y: myMesh.position.y, z: myMesh.position.z, color: myColor });
  }

  // smooth others
  others.forEach(entry=>{
    entry.mesh.position.lerp(entry.target, 0.1);
  });

  controls.target.lerp(myMesh.position,0.06);
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

</script>
</body>
</html>
