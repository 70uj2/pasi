<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Multiplayer Character with Orbit Camera</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #colorPicker { position: absolute; top: 10px; left: 10px; z-index: 10; }
  </style>
</head>
<body>
<input type="color" id="colorPicker">
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
document.addEventListener('contextmenu', e => e.preventDefault());

const firebaseConfig = {
  apiKey: "AIzaSyC_Op87WdFH-xBlbyBPgH66LilwGZ8Ch5w",
  authDomain: "pasja-data5100s.firebaseapp.com",
  projectId: "pasja-data5100s",
  storageBucket: "pasja-data5100s.firebasestorage.app",
  messagingSenderId: "1042573635103",
  appId: "1:1042573635103:web:9f70d20e5ac49f951b6f2a",
  measurementId: "G-Z2GYGXQTMZ"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambient);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(5,10,7);
dirLight.castShadow = true;
scene.add(dirLight);

const gridHelper = new THREE.GridHelper(200, 40, 0x444444, 0x888888);
scene.add(gridHelper);

let playerId = Math.random().toString(36).substr(2,5);
let player, players = {};

function createCharacterModel(hex = '#888888') {
  const group = new THREE.Group();
  const baseMat = new THREE.MeshStandardMaterial({ color: hex });

  const torso = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), baseMat.clone());
  torso.position.set(0, 3, 0);
  group.add(torso);

  const head = new THREE.Mesh(new THREE.BoxGeometry(1.25, 1.25, 1.25), baseMat.clone());
  head.position.set(0, 4.625, 0);
  group.add(head);

  const leftArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), baseMat.clone());
  leftArm.position.set(-1.5, 3, 0);
  group.add(leftArm);

  const rightArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), baseMat.clone());
  rightArm.position.set(1.5, 3, 0);
  group.add(rightArm);

  const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), baseMat.clone());
  leftLeg.position.set(-0.5, 1, 0);
  group.add(leftLeg);

  const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), baseMat.clone());
  rightLeg.position.set(0.5, 1, 0);
  group.add(rightLeg);

  // bigger bevel cubes pushed outward so they're visible
  const bevelGeom = new THREE.BoxGeometry(0.6, 0.6, 0.6);
  const bevelPositions = [
    [-1.8,4,0],[1.8,4,0],   // shoulders
    [-0.8,0,0],[0.8,0,0]    // feet
  ];
  for (const p of bevelPositions) {
    const b = new THREE.Mesh(bevelGeom, baseMat.clone());
    b.position.set(p[0], p[1], p[2]);
    group.add(b);
  }

  group.setColor = function(hexColor) {
    group.traverse(n => {
      if (n.isMesh && n.material) n.material.color.set(hexColor);
    });
  };
  return group;
}

player = createCharacterModel('#888888');
scene.add(player);

const colorInput = document.getElementById('colorPicker');
colorInput.value = '#888888';
colorInput.addEventListener('input', e => {
  const c = e.target.value;
  player.setColor(c);
  db.ref('players/' + playerId).update({ color: c });
});

db.ref('players').on('value', snapshot => {
  const data = snapshot.val() || {};
  for (const id in data) {
    if (id === playerId) continue;
    const entry = data[id];
    if (!players[id]) {
      players[id] = createCharacterModel(entry.color || '#888888');
      scene.add(players[id]);
    }
    players[id].position.set(entry.x||0, entry.y||0, entry.z||0);
    if (entry.color) players[id].setColor(entry.color);
  }
  for (const id in players) {
    if (!data[id]) { scene.remove(players[id]); delete players[id]; }
  }
});

let keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function updatePlayer() {
  let speed = 0.1;
  if (keys['w']) player.position.z -= speed;
  if (keys['s']) player.position.z += speed;
  if (keys['a']) player.position.x -= speed;
  if (keys['d']) player.position.x += speed;
  db.ref('players/' + playerId).set({
    x: player.position.x,
    y: player.position.y,
    z: player.position.z,
    color: colorInput.value
  });
}

// ---- custom orbit camera ----
let isDragging = false;
let prevMouse = {x:0, y:0};
let orbit = {yaw:0, pitch:0, dist:10};

renderer.domElement.addEventListener('mousedown', e=>{
  isDragging = true;
  prevMouse.x = e.clientX;
  prevMouse.y = e.clientY;
});
renderer.domElement.addEventListener('mouseup', ()=> isDragging=false);
renderer.domElement.addEventListener('mousemove', e=>{
  if(!isDragging) return;
  let dx = e.clientX - prevMouse.x;
  let dy = e.clientY - prevMouse.y;
  orbit.yaw -= dx * 0.005;
  orbit.pitch -= dy * 0.005;
  orbit.pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, orbit.pitch));
  prevMouse.x = e.clientX;
  prevMouse.y = e.clientY;
});
renderer.domElement.addEventListener('wheel', e=>{
  orbit.dist += e.deltaY*0.01;
  orbit.dist = Math.max(4, Math.min(30, orbit.dist));
});

function updateCamera() {
  const offsetX = orbit.dist * Math.sin(orbit.yaw) * Math.cos(orbit.pitch);
  const offsetY = orbit.dist * Math.sin(orbit.pitch);
  const offsetZ = orbit.dist * Math.cos(orbit.yaw) * Math.cos(orbit.pitch);
  camera.position.set(
    player.position.x + offsetX,
    player.position.y + 3 + offsetY,
    player.position.z + offsetZ
  );
  camera.lookAt(player.position.x, player.position.y+3, player.position.z);
}

function animate() {
  requestAnimationFrame(animate);
  updatePlayer();
  updateCamera();
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
