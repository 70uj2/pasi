<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Multiplayer Cubes</title>
  <style>
    body { margin:0; overflow:hidden; }
    #colorPicker {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1;
    }
  </style>
</head>
<body>
  <input type="color" id="colorPicker" value="#ff0000">

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/OrbitControls.js";

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 5, 10);
    controls.update();

    // Lighting
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(50, 50),
      new THREE.MeshPhongMaterial({ color: 0x808080 })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Player model (Roblox-style proportions)
    function createPlayer(color = 0xff0000) {
      const group = new THREE.Group();

      const material = new THREE.MeshPhongMaterial({ color });

      // Torso
      const torso = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), material);
      torso.position.y = 3;
      group.add(torso);

      // Head
      const head = new THREE.Mesh(new THREE.BoxGeometry(1.25, 1.25, 1.25), material);
      head.position.y = 4.75;
      group.add(head);

      // Arms
      const leftArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), material);
      leftArm.position.set(-1.5, 3.5, 0);
      leftArm.name = "leftArm";
      group.add(leftArm);

      const rightArm = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), material);
      rightArm.position.set(1.5, 3.5, 0);
      rightArm.name = "rightArm";
      group.add(rightArm);

      // Legs
      const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), material);
      leftLeg.position.set(-0.5, 1, 0);
      leftLeg.name = "leftLeg";
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), material);
      rightLeg.position.set(0.5, 1, 0);
      rightLeg.name = "rightLeg";
      group.add(rightLeg);

      return group;
    }

    const player = createPlayer();
    scene.add(player);

    // Controls
    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    // 2014 Walk Animation (from uploaded video)
    let walkTime = 0;
    function animateWalk(character, moving, delta) {
      const leftArm = character.getObjectByName("leftArm");
      const rightArm = character.getObjectByName("rightArm");
      const leftLeg = character.getObjectByName("leftLeg");
      const rightLeg = character.getObjectByName("rightLeg");

      if (!leftArm || !rightArm || !leftLeg || !rightLeg) return;

      if (moving) {
        // speed tuned to ~40 frames per cycle @30fps ≈ 1.33s per cycle
        walkTime += delta * 4.7;

        // Arms swing wider (~45°)
        const armSwing = Math.sin(walkTime) * (Math.PI / 4); // ±45°
        // Legs swing narrower (~30°)
        const legSwing = Math.sin(walkTime) * (Math.PI / 6); // ±30°

        leftArm.rotation.x = armSwing;
        rightArm.rotation.x = -armSwing;
        leftLeg.rotation.x = -legSwing;
        rightLeg.rotation.x = legSwing;
      } else {
        // Reset smoothly toward idle
        leftArm.rotation.x *= 0.8;
        rightArm.rotation.x *= 0.8;
        leftLeg.rotation.x *= 0.8;
        rightLeg.rotation.x *= 0.8;
      }
    }

    // Update loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      let moving = false;
      const speed = 5 * delta;

      if (keys["w"]) { player.position.z -= speed; moving = true; }
      if (keys["s"]) { player.position.z += speed; moving = true; }
      if (keys["a"]) { player.position.x -= speed; moving = true; }
      if (keys["d"]) { player.position.x += speed; moving = true; }

      animateWalk(player, moving, delta);

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Color picker
    document.getElementById("colorPicker").addEventListener("input", (e) => {
      player.traverse(child => {
        if (child.isMesh) child.material.color.set(e.target.value);
      });
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
